import { dirname } from "path";
import { fileURLToPath } from "url";

import StyleDictionary from "style-dictionary";
import { transformGroups } from "style-dictionary/enums";

const log = (value) => console.log("\x1b[36m%s\x1b[0m", value);

log("Design Tokens Build started...");

const __dirname = dirname(fileURLToPath(import.meta.url));
const tokenSource = `${__dirname}/tokens/design-tokens.json`;
const buildPath = `${__dirname}/gen/`;

const customTsFormat = "custom/lbank/ts/tokens";
const customScssFormat = "custom/lbank/scss/tokens";

const metaHeader = `
// Do not edit directly, this file was auto-generated.
// Generated on ${new Date().toUTCString()}
`;

function capitalize(value) {
  return value
    .split("-")
    .map((part) => `${part[0].toUpperCase()}${part.slice(1)}`);
}

StyleDictionary.registerFormat({
  name: customTsFormat,
  format: ({ dictionary, options }) => {
    const cssVar = options?.varPrefix?.css
      ? `--${options.varPrefix.css}-`
      : "--";
    const scssVar = options?.varPrefix?.scss
      ? `$${options.varPrefix.scss}-`
      : "$";

    const tokens = dictionary.allTokens.reduce((obj, token) => {
      const category = token.attributes.category;

      if (category !== options.categoryName.semantic) {
        return obj;
      }

      const group = token.attributes.type;
      const [, ...rest] = token.path;
      const nameList = capitalize(rest.join("-"));

      const css =
        category === options.categoryName.semantic
          ? `var(${cssVar}${rest.join("-")})`
          : undefined;

      return {
        ...obj,
        [category]: {
          ...obj?.[category],
          [group]: [
            ...(obj?.[category]?.[group] ?? []),
            {
              name: nameList.slice(1).join(" "),
              fullName: nameList.join(" "),
              category,
              group,
              token: `${scssVar}${rest.join("-")}`,
              type: token.type,
              value: token.value,
              css,
            },
          ],
        },
      };
    }, {});

    return `
            ${metaHeader}

            export interface DesignToken {
                name: string;
                fullName: string;
                category: string;
                group: string;
                token: string;
                type: string;
                value: string;
                css?: string;
            }

            export interface DesignTokens {
                [category: string]: {
                    [group: string]: DesignToken[];
                };
            }

            export const designTokens: DesignTokens = ${JSON.stringify(tokens)};

            export default designTokens;
        `;
  },
});

StyleDictionary.registerFormat({
  name: customScssFormat,
  format: ({ dictionary, options }) => {
    const tokens = dictionary.allTokens.reduce(
      (obj, t) => ({
        ...obj,
        [t.attributes.category]: {
          ...obj[t.attributes.category],
          [t.key]: t,
        },
      }),
      {}
    );

    const cssVar = options?.varPrefix?.css
      ? `--${options.varPrefix.css}-`
      : "--";
    const scssVar = options?.varPrefix?.scss
      ? `$${options.varPrefix.scss}-`
      : "$";

    const cssVars = Object.values(tokens[options.categoryName.semantic]).map(
      (v) => {
        const name = v.name.replace(
          `${options.categoryName.semantic}-`,
          cssVar
        );
        const value =
          tokens[options.categoryName.primitive][v.original.value].value;

        return `${name}: ${value};`;
      }
    );

    const scssSemantic = Object.values(
      tokens[options.categoryName.semantic]
    ).map((v) => {
      const name = v.name.replace(`${options.categoryName.semantic}-`, scssVar);
      const value = v.name.replace(`${options.categoryName.semantic}-`, cssVar);

      return `${name}: var(${value});`;
    });

    const scssComponent = Object.values(
      tokens[options.categoryName.component]
    ).map((v) => {
      const name = v.name.replace(
        `${options.categoryName.component}-`,
        scssVar
      );
      const semantic = tokens.semantic[v.original.value].name;
      const value = semantic.replace(
        `${options.categoryName.semantic}-`,
        scssVar
      );

      return `${name}: ${value};`;
    });

    return `
            ${metaHeader}

            @mixin lightCssCustomProperties {
                ${cssVars.sort().join("\n")}
            }

            // Semantic Design Tokens - Themeable tokens
            ${scssSemantic.sort().join("\n")}

            // Component Design Tokens - Component specific composition tokens
            ${scssComponent.sort().join("\n")}
        `;
  },
});

// Apply the configuration
// IMPORTANT: the registration of custom transforms needs to be done _before_ applying the configuration
const sd = new StyleDictionary({
  source: [tokenSource],
  platforms: {
    scss: {
      transformGroup: transformGroups.scss,
      buildPath,
      files: [
        {
          destination: "design-tokens.scss",
          format: customScssFormat,
          options: {
            categoryName: {
              primitive: "primitive",
              semantic: "semantic",
              component: "component",
            },
            varPrefix: {
              css: "theme",
              scss: "ui",
            },
          },
        },
      ],
    },
    ts: {
      transformGroup: transformGroups.js,
      buildPath,
      files: [
        {
          destination: "design-tokens.ts",
          format: customTsFormat,
          options: {
            categoryName: {
              primitive: "primitive",
              semantic: "semantic",
              component: "component",
            },
            varPrefix: {
              css: "theme",
              scss: "ui",
            },
          },
        },
      ],
    },
  },
});

// Build all the Platforms
await sd.buildAllPlatforms();

log("\nDesign Tokens Build completed!\n\nPrettier format:");
